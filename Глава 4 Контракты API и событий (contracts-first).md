# 4\. Контракты API и событий (contracts-first) — финальная редакция v1

Зачем эта глава: зафиксировать **публичные REST-контракты** Mini App-бэкенда и **модель доменных событий**, чтобы фронт, мобильный контейнер Telegram, Co-DM-редактор, билдер приключений и операционные сервисы работали синхронно. Всё формализовано в **OpenAPI 3.1 + JSON Schema 2020-12** и **CloudEvents 1.0.2**, с единым стилем ошибок, идемпотентностью, трассировкой и политикой эволюции схем. Это соответствует лучшим индустриальным практикам (OpenAPI/JSON Schema, CloudEvents, W3C Trace Context, Telegram initData, Stripe-style идемпотентность, Microsoft/Google гайдлайны).

## 4.0 Область и принципы

- **Contracts-first:** «истина» — в репозитории @rpg/contracts: openapi/, jsonschema/, events/, примеры, автоген SDK. (Нужны воспроизводимость, статический анализ и автодоки.)
- **Эволюция без боли:** версии в URI (/v1), аддитивные изменения назад-совместимы; breaking → новая мажорная версия/тип события.
- **Наблюдаемость/откат:** единый формат ошибок (в духе Google AIP-193), traceparent заголовки для сквозной трассировки, идемпотентность всех мутаций.

## 4.1 Синхронные API (REST, /v1)

### 4.1.1 Версионирование и спецификация

- **Версия в пути:** https://api.rpg.bot/v1/... (стабильные кеши/маршрутизация; старые версии продолжают работать).
- **OAS 3.1 + JSON Schema 2020-12:** единая валидируемая модель, webhooks-раздел для исходящих уведомлений документируется прямо в OAS.

**Зачем:** единый источник правды, автоген клиентов (TS/JS/Python), контрактные тесты и линт в CI.

### 4.1.2 Аутентификация и сессии (Telegram Mini Apps)

- Клиент даёт tgWebAppData (**initData**) → сервер **валидирует подпись и свежесть**, после чего выпускает наш короткоживущий **JWT** (далее — стандартный Bearer-поток). Валидное требование Telegram — использовать **только** провалидированные сервером данные из initData.

**Смысл:** дешёвый вход без логина/пароля и строгая привязка к Telegram-пользователю; снижение риска подмены. (Время жизни нашего JWT соответствует политике сессий из гл.3.)

### 4.1.3 Идемпотентность и ретраи

- **Все мутации** (POST/PUT/PATCH/DELETE) требуют заголовок Idempotency-Key: &lt;ULID/UUID&gt;; сервер хранит **результат** по ключу 24–72ч и возвращает **тот же** ответ при повторах с теми же параметрами. Ключи автоматически «сметаются» после 24ч (рекомендация Stripe).

**Смысл:** безопасные ретраи из клиента/воркера без дублей (покупки, списания, публикации модулей).

### 4.1.4 Пагинация и сортировка

- **Cursor/Continuation-token:** ответ { items: \[...\], next: "&lt;opaque&gt;" }; клиент передаёт next как есть, не меняя query. Это масштабируемее page/limit и устойчиво к вставкам между страницами.

**Смысл:** быстрые ленты (журналы, рынки, библиотеки) без потери консистентности.

### 4.1.5 Формат ошибок

- Единый JSON-объект:

{

"error": {

"code": "INVALID_ARGUMENT",

"message": "Field 'name' is required",

"details": \[{"field":"name","rule":"required"}\],

"request_id": "req_123",

"trace_id": "00-abcd...-ef01-01",

"doc_url": "https://docs.rpg/api/errors#invalid_argument"

}

}

- Коды HTTP: 400/401/403/404/409/422/429/5xx. Сообщения **понятные и действенные** (AIP-193, Google Tech Writing). На 429 обязательно Retry-After.

**Смысл:** стабильный парсинг, лучшая отладка, здоровая DX.

### 4.1.6 Трассировка и корреляция

- Принимаем/прокидываем **W3C Trace Context**: traceparent/tracestate → кладём trace_id в тело ошибок и расширения событий (см. 4.2).

**Смысл:** связать логи REST ↔ шину событий ↔ алерты.

### 4.1.7 Частичные обновления и долгие операции

- Частичные апдейты — PATCH (JSON Merge Patch) для точечных правок.
- Долгие медиа-задачи (GEN-I/TTS) — синхронный 202 Accepted { job_id } + событие завершения/ошибки (см. 4.2). (Документируется и как REST, и в webhooks OAS 3.1.)

### 4.1.8 Webhooks (исходящие вызовы наружу)

- Для внешних интеграций (платежи/модерация/маркетплейс) — **подписанные HMAC-вебхуки**: заголовки X-RPG-Timestamp, X-RPG-Signature: sha256=..., окно 5 минут, сравнение в **constant-time**. Документация через openapi.webhooks.

**Смысл:** безопасная доставка без опроса; понятная DX (схема тела/подписи в OAS).

## 4.2 Асинхронные события (доменная шина)

### 4.2.1 Базовый формат и типы

- **CloudEvents 1.0.2 (JSON)**: атрибуты id, source, type, specversion, time, subject, data (+ наше расширение trace_id). Типы именуем с пространством rpg.\*.v1 (версия в типе).

**Примеры типов (MVP):**

- rpg.run.turn.started.v1, rpg.run.choice.submitted.v1, rpg.party.vote.updated.v1,
- rpg.combat.action.resolved.v1,
- rpg.media.job.created.v1|done.v1|failed.v1,
- rpg.gm.override.applied.v1.

**Зачем:** единая совместимость между сервисами/шинами/хранилищами.

### 4.2.2 Доставка, порядок, дедупликация

- Гарантия **at-least-once**; порядок **внутри ключа** (partition key = campaign_id/party_id); ретраи с экспоненциальной задержкой и DLQ.
- Идемпотентность на потребителе по event.id (store-once). Практика идентична идемпотентным HTTP-мутациям, адаптирована к CloudEvents.

**Смысл:** простая, предсказуемая обработка без двойных эффектов.

### 4.2.3 Трассировка событий

- Прокидываем trace_id (копия из traceparent) в **расширении** CloudEvents, чтобы собирать end-to-end цепочки.

### 4.2.4 Эволюция схем

- Изменения **аддитивны** (добавлять поля); breaking → **новый type** (…v2). В реестре событий храним **JSON Schema** для data и «золотые» примеры.

## 4.3 Пакет контрактов, CI/CD и SDK

### 4.3.1 Структура @rpg/contracts

/openapi/rpg-bot.yaml # OAS 3.1 (REST + webhooks)

/jsonschema/\*.schema.json # модели (Scene, Node, Item, …)

/events/\*.json # CloudEvents types + data-schemas

/examples/rest/\*.json # golden-запросы/ответы

/examples/events/\*.json # golden-события

/ci/validate.sh # oas+schema линт/валидация

- Линт/валидация в CI (ajv/экв.) и **детектор breaking-изменений**; автоген SDK (TS/JS/Python) из OAS.

**Смысл:** любая команда подхватывает изменения контрактов сразу и безопасно.

## 4.4 Референс-контракты (фрагменты для разработчиков)

### 4.4.1 Cursor-пагинация

**GET** /v1/library/adventures?tag=heist&limit=25

{

"items": \[ /\* 25 штук \*/ \],

"next": "eyJjYW1wYWlnbl9pZCI6ICJjXzQyIiwgIm9mZnNldCI6IDEyNX0="

}

**GET** /v1/library/adventures?next=eyJjYW... → следующая страница. (Токен непрозрачный; клиент не меняет исходный query.)

### 4.4.2 Ошибка 429 с рекомендацией ретрая

HTTP/1.1 429 Too Many Requests

Retry-After: 120

Content-Type: application/json

{

"error": {

"code": "RATE_LIMIT_EXCEEDED",

"message": "Try again in 120 seconds.",

"request_id": "req_9f8...",

"trace_id": "00-1c2...-01"

}

}

Руководствуемся RFC-6585/MDN и экспоненциальным backoff на клиенте.

### 4.4.3 Идемпотентный POST

POST /v1/media/gen-image

Idempotency-Key: 01J7...ULID

{

"sceneId": "S-001",

"kind": "background",

"promptRef": "img:graveyard.v1"

}

Повтор с тем же ключом и телом вернёт **тот же** 200/202 и job_id. Ключи можно чистить через ≥24ч

### 4.4.4 Telegram initData → JWT

Клиент присылает tgWebAppData; сервер:

1.  Проверяет подпись и auth_date (TTL/защита от повторов);
2.  Резолвит/создаёт пользователя;
3.  Отдаёт 200 { access_token, expires_in } (наш JWT).

Использовать **только провалидированные** на сервере данные initData.

### 4.4.5 Webhooks (HMAC)

**Подпись:** X-RPG-Timestamp, X-RPG-Signature: sha256=&lt;hex(hmac(secret, ts + '.' + body))&gt;; окно 5 минут; constant-time сравнение. Ротация секретов поддерживается

## 4.5 Безопасность, квоты, кеши

- **Rate-limits:** 429 + Retry-After; хедеры X-RateLimit-\* в ответах.
- **ETag/If-None-Match** на GET-справочники; кэш медиа-результатов по хэшу запроса (как в гл.3).
- **Подписи вебхуков HMAC-SHA256**; опциональный allow-list источников.

**Смысл:** контролируем издержки и обеспечиваем прогнозируемость SLA.

## 4.6 DoR / DoD (глава 4) и артефакты

**DoR (готовность):**

- Приняты: /v1-версирование, OAS 3.1 + JSON Schema как «истина», cursor-пагинация, формат ошибок (AIP-193-style), W3C Trace Context, идемпотентность мутаций, CloudEvents 1.0.2 с rpg.\*.v1, HMAC-вебхуки, Telegram initData→JWT.

**DoD (выпуск):**

- openapi/rpg-bot.yaml (включая раздел webhooks, ошибки, пагинацию, идемпотентность);
- jsonschema/\*.schema.json (модели домена);
- events/registry.json (типы rpg.\*.v1, расширение trace_id, схемы data);
- examples/\* (golden REST/CloudEvents);
- CI-валидация (OAS + JSON Schema), breaking-детектор, автоген SDK.

### Примечания «зачем это всё»

- **OpenAPI 3.1 + JSON Schema** → типобезопасные клиенты, меньше багов интеграции и «сюрпризов» при релизах.
- **CloudEvents** → единый стандарт событий → меньше кода адаптеров и проще подключать брокеры/хранилища.
- **Trace Context** → связная диагностика инцидентов «от кнопки до вебхука».
- **Идемпотентность/429/Retry-After** → безопасные ретраи без дублей и понятное поведение на пределе квот.
- **Telegram initData→JWT** → бесшовный SSO и соблюдение требований безопасности Mini Apps.