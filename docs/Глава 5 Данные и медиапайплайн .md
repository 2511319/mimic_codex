# 5\. Данные и медиапайплайн — финальная редакция v1

Цель главы — зафиксировать **как и зачем** мы храним данные, проводим миграции и обрабатываем медиа (TTS/ASR/IMG/Avatar): очереди, кеши, TTL, CDN/подписи, ретраи, анти-абьюз, наблюдаемость и стоимость. В основе — лучшие практики **PostgreSQL + Alembic**, **идемпотентные API**, **Cloud/CDN signed URLs**, **W3C Trace Context**, **Cloud STT/TTS**. Ссылки на ключевые источники приводятся по месту.

## 5.0 Принципы и границы

- **Data-first:** нормализуем горячие поля, а «длинные хвосты» — в JSONB (индексы под запросы).
- **История и аудит:** храним **журналы изменений**, а не просто soft-delete. Это даёт воспроизводимость и поддержку реткона/аудита.
- **Миграции без даунтайма:** expand/contract, индексы **CONCURRENTLY**, ревизии Alembic под CI.
- **Идемпотентные мутации:** Idempotency-Key на все write-операции → безопасные ретраи без дублей.
- **CDN + подписанные URL:** управляем доступом/TTL к медиа, ротация ключей.
- **Наблюдаемость end-to-end:** traceparent/tracestate и trace_id в событиях/ошибках.

## 5.1 Данные и миграции

### 5.1.1 ERD (ядро, кратко)

**Таблицы (укороченный состав):**

- users (PII вынесена отдельно users_pii)
- campaigns, parties, turns, rolls
- inventory, items, rewards
- media_jobs (TTS/ASR/IMG/Avatar)
- moderation_flags
- audits (системный/GM-аудит)
- usage_costs (учёт затрат по провайдеру/типу)
- assets (Vault), assets_hashes (crypto + **perceptual**)

**Почему так:** горячие сущности — нормализованы (быстрые JOIN), а метаданные сцен/ассетов/настроек — JSONB c целевыми индексами (гибкая эволюция без ломких миграций).

### 5.1.2 Ключи, индексы, партиционирование

- **ID:** ULID/UUIDv7 (время-упорядоченность, удобнее партиционировать по времени поступления).
- **Индексы:** B-tree по FK и частые фильтры; GIN по JSONB-полям (теги/поиск).
- **Партиции:** «длинные» таблицы (turns, rolls, media_jobs, audits) — по времени (неделя/месяц), заранее создаём будущие партиции (нет стопов).

### 5.1.3 История, удаление, GDPR

- **Audited-history:** журнал изменений через триггеры/лог на запись (до/после). Восстановление состояния на любой момент времени.
- **Право на забвение:** PII отдельно → де-идентификация/удаление без ломки журналов.

### 5.1.4 Миграции (Alembic)

- **Процесс:** ревизии на PR, тест миграций в CI, dry-run на staging.
- **Тяжёлые операции:** ADD COLUMN (nullable) → backfill batch’ами → SET NOT NULL; индексы CONCURRENTLY; стратегия **expand/contract**.
- **Outbox/Saga:** межсервисные эффекты не зависят от транзакции OLTP.

### 5.1.5 Идемпотентность и ретраи

- Все write-эндпойнты принимают Idempotency-Key. Результат (статус/тело) кэшируется 24–72ч; повтор с тем же телом → **тот же** ответ. Практика Stripe.
- На 429 возвращаем Retry-After и понятную диагностику (RFC 6585, MDN).

## 5.2 Медиа-пайплайн (TTS/ASR/IMG/Avatar)

### 5.2.1 Архитектура и очереди

Client → REST /v1/media/\* → Job Orchestrator → { TTS | ASR | IMG | Avatar } Workers

← 202 {job_id} ↑ metrics/trace ↓

← events: done/failed ← DLQ/alerts CDN/S3 (signed URLs)

- **Очереди per-тип**: tts, asr, img, avatar; приоритеты realtime / standard / bulk (VDM → tts.realtime, сцены → tts.standard).
- **Ретраи:** экспоненциальный backoff, **DLQ** по N попыток, алерты в Ops.
- **Идемпотентность работ:** ключ = **контент-хэш запроса** (см. 5.2.4) → исключаем дубли.

### 5.2.2 Форматы и **транскодер** (ответ на вопрос про «в каком формате отвечает модель»)

- **Какие форматы реально приходят от провайдеров:**
    - Многие Image-API возвращают **base64** изображения; **дефолт — PNG**, но можно запросить **JPEG/WEBP** (зависит от провайдера).
    - У Stability/Bedrock можно выбрать **PNG/JPEG** и даже получить **image/png** напрямую по Accept.
    - Площадки вроде Midjourney часто отдают **WebP/JPEG** в клиентских каналах (Discord), что требует сервера-агрегатора и конвертации для нашего CDN.

**Решение:** Вводим **Media Transcoder**:

- **Вход:** PNG|JPEG|WEBP|base64 (детект по заголовку/магическим байтам).
- **Выход (наш стандарт):**
    - **Фоны/сцены:** **WebP/AVIF** (меньший вес для сети).
    - **Предметы/портреты с альфой:** **PNG (lossless)**.
- **Смысл:** единый визуальный стандарт в клиенте + экономия трафика; прозрачная поддержка любых провайдеров изображений.
- **Пайплайн:** decode → sanitize (ICC/EXIF strip) → resize → convert → hash → store (CDN/S3).
- **Fallback:** если конвертация в AVIF недоступна на платформе, используем WebP.

### 5.2.3 STT/TTS — задержки и кеши

- **ASR (стриминг VDM):** размер фрейма ~**100 мс** — оптимум по задержке/эффективности (рекомендация Google Speech).
- **TTS:** кешируем часто повторяемые фразы **на уровне аудио-файлов** (MP3/OGG), экономим вызовы и latency. Практика индустрии/документаций TTS.
- **Prompt-кеш для LLM:** кешируем длинные подсказки/прологи, чтобы не платить повторно (ключ провайдера prompt-cache).

### 5.2.4 Кеши и TTL

**Ключи кеша (контент-хэш):**

- **IMG:** hash(prompt + style + seed + size + model + postproc).
- **TTS:** hash(text + voice + speed + model).
- **ASR:** hash(audio_bytes + lang + model).

**TTL (дефолт):**

- **IMG/Avatar:** CDN TTL ~ **30 дн.** (инвалидация по версии).
- **TTS/ASR:** **7–30 дн.** (баланс приватности и повторного использования).

**Доставка:** **CDN signed URLs/cookies** + ротация ключей; 2–3 активных ключа для переезда без даунтайма.

### 5.2.5 Модерация/дедуп

- **Перцептуальные хэши** (pHash/dHash/aHash) — детект «почти дублей», анти-абьюз и экономия хранилища; сравнение по **Hamming distance**.
- **Риски pHash:** уязвим к обходам → используем **комбинацию** методов и пороги, граничные кейсы — ручная модерация.

### 5.2.6 Кодеки/форматы воспроизведения

- **Аудио (Mini App):** **MP3** (совместимость) + OGG/Opus (опционально); 24–48 кГц; моно — для голоса (меньше вес).
- **Изображения:** **WebP/AVIF** для фонов; **PNG** для предметов/портретов (альфа-канал). (Нужен был уточняющий ответ — мы зафиксировали стандарт и добавили конвертер, см. 5.2.2.)

### 5.2.7 SLO и деградации

- **Цели (p95):** TTS ≤ **1.0–1.5 с**; ASR partial ≤ **1.2 с**; IMG (кеш) ≤ **300 мс**; IMG (генерация) — 202 Accepted + прогресс по событиям.
- **Circuit-breaker:** по error-rate/latency провайдера — переключение на резерв; записи в алерты Ops.
- **429/Rate-limits:** сервер чётко указывает Retry-After; клиенты уважают backoff.

## 5.3 Безопасность и приватность

- **Signed URLs** для приватных медиа (временные ссылки, ротация ключей).
- **PII минимизация:** аудио/ASR-лог хранить по TTL 7–30 дн.; EXIF/ICC в изображениях вычищаем.
- **Трассировка:** в ответы API — traceparent/tracestate и trace_id в теле ошибок; тот же trace_id попадает в CloudEvents (расширение).

## 5.4 Наблюдаемость и стоимость

- **Метрики per очередь/провайдер:** latency p50/p95, success-rate, cost/unit, cache-hit, DLQ-rate.
- **Учёт затрат:** usage_costs на каждый media_job (провайдер, модель, мин., стоимость) → агрегации по кампании/пользователю.
- **Синтетические прогоны:** крон-проверки эталонных TTS/ASR/IMG запросов (golden-fixtures) и сравнение бюджета/latency со вчера.

## 5.5 Протоколы ответа и ошибки (фрагменты)

**202 Accepted (долгая генерация изображения):**

POST /v1/media/gen-image

Idempotency-Key: 01J8...ULID

→ 202

{ "job_id": "mjob_42", "status": "queued", "trace_id": "00-..." }

**Событие CloudEvents об успехе:**

{

"specversion":"1.0",

"type":"rpg.media.job.done.v1",

"source":"media.img",

"id":"evt_9f8...",

"time":"2025-08-27T12:34:56Z",

"subject":"mjob_42",

"data":{ "cdn_url":"https://cdn/..../bg.webp", "format":"webp" , "bytes": 184532 },

"extensions":{ "trace_id":"00-..." }

}

(CloudEvents стандартизирует перенос событий и совместимость с шинами.)

**429 Too Many Requests:**

HTTP/1.1 429 Too Many Requests

Retry-After: 120

Content-Type: application/json

{ "error": { "code":"RATE_LIMIT_EXCEEDED", "message":"Try again in 120 seconds.", "trace_id":"00-..." } }

(Требование _Retry-After_ — по RFC/MDN.)

## 5.6 Конфигурации и политики (выжимка)

### 5.6.1 Storage & TTL Policy (выдержка)

img:

cache_key: "hash(prompt,style,seed,size,model,postproc)"

ttl_cdn_days: 30

delivery: "cdn_signed_urls"

formats: { bg: "webp|avif", item: "png" }

tts:

cache_key: "hash(text,voice,speed,model)"

ttl_days: 7-30

asr:

cache_key: "hash(audio,lang,model)"

ttl_days: 7-30

signed_urls:

keys_active: 3

rotate_days: 30

### 5.6.2 Transcoder Policy

input_formats: \["image/png","image/jpeg","image/webp","base64"\]

output:

scene_bg: { preferred: "avif", fallback: "webp" }

portrait_item: { preferred: "png" }

sanitize: { strip_exif: true, color_profile: "sRGB" }

### 5.6.3 Queues

queues:

tts: { priorities: \["realtime","standard","bulk"\], dlq: "tts.dlq" }

asr: { priorities: \["realtime","standard"\], dlq: "asr.dlq" }

img: { priorities: \["standard","bulk"\], dlq: "img.dlq" }

avatar: { priorities: \["standard"\], dlq: "avatar.dlq" }

retry:

policy: "exponential"

max_attempts: 5

## 5.7 DoR / DoD и артефакты

**DoR (готовность):**

- Утверждены: ER-модель (ядро), партиционирование по времени, журналы истории; Alembic-процесс и expand/contract; идемпотентность write-API; очереди медиа per-тип + DLQ; контент-кеши (ключи/TTL); CDN signed URLs; STT-фреймы 100мс; TTS/Prompt-кеш; перцептуальные хэши; SLO и 429/Retry-After; трассировка traceparent + trace_id.

**DoD (выпуск в репозиторий):**

- docs/ERD.png (ключевые таблицы + партиции).
- policies/Storage&TTL.md (TTL/кеши/подписи/приватность).
- policies/Transcoder.md (вход/выход/санитайзинг/ICC/EXIF/remove).
- infra/queues.yaml (очереди/приоритеты/DLQ/retry).
- ops/SLO.md и ops/alerts.md (циркут-брейкер, алерты).
- media/providers_matrix.md (провайдеры, форматы, поддержка base64/PNG/JPEG/WEBP, цены; наличие Accept: image/png).
- security/cdn_signed_urls.md (ротация ключей/окна подписи).
- ci/migrations.md (ревизии Alembic, dry-run, concurrent-индексы).

## 5.8 Зачем всё это (кратко)

- **Журналы истории** → объяснимость, реткон без потери данных, восстановление инцидентов
- **Expand/contract миграции** → релизы без даунтайма.
- **Idempotency-Keys + 429/Retry-After** → безопасные ретраи и предсказуемое поведение на пределе квот.
- **Signed URLs + TTL** → защищённые медиа с контролируемыми окнами доступа.
- **100 мс ASR-фрейм + TTS/Prompt-кеш** → низкая задержка VDM/озвучки при экономии затрат.
- **Транскодер** → независимость от форматов провайдера (base64/PNG/JPEG/WEBP) и единый стандарт клиента.