# RPG‑Bot: Видение продукта

## Назначение

Этот документ фиксирует финальное видение продукта: цели, тип, базовую идею, целевую аудиторию, ценностные сценарии, архитектурные границы и стратегические решения.

## Продукт в одном абзаце

RPG‑Bot — модульная платформа для кооперативных ролевых приключений в Telegram Mini App с поддержкой живой синхронизации партии, генеративного контента (сюжеты, сцены, иллюстрации, озвучка) и осмысленной памяти кампаний. Платформа построена по принципу contracts‑first, расширяема через плагины (провайдеры ИИ, хранилища, фичи UI), и поставляется как набор независимых микросервисов и фронтенд‑feature модулей.

## Целевая аудитория

- Игроки и мастера (GM) настольных и сюжетных RPG в мессенджере.
- Сообщества и микрогруппы для совместных сессий «на ходу».
- Создатели контента (лоры, модули, кампании), желающие публиковать новые фичи.

## Базовая идея и ценность

- «GM‑ассистент в кармане»: быстрый старт и поддержка сюжетной динамики без подготовки.
- Живое взаимодействие партии: синхронные события, голосования, таймеры, реплей истории.
- Генеративные элементы с проверяемой структурой: сцены, NPC, бои, иллюстрации, TTS‑озвучка.
- Память кампании: поиск и повторное использование знаний/лора на основе векторного индекса.
- Расширяемость: простое подключение новых провайдеров медиагенерации и фич UI без форка «ядра».

## Тип продукта

- Клиент: Telegram Mini App (Vite + React + TypeScript), «app‑shell» с feature‑модулями.
- Сервер: набор микросервисов (FastAPI): gateway_api (auth/JWT/REST), party_sync (WS), media_broker (очереди медиа).
- Общие пакеты: rpg_contracts (контракты), genlayers (генерация, structured outputs), memory37 (память/поиск).

## Стратегические решения

- Провайдер ИИ: OpenAI (основной). Абстракции для смены/добавления провайдеров сохраняются.
- Память: PostgreSQL + pgvector для векторного индекса и метаданных.
- Облако/хостинг: не зафиксировано; архитектура cloud‑neutral (контейнеры, 12‑factor, конфиг через env).
- Фронтенд‑модули: старт — app‑shell + feature registry + lazy‑imports; опциональный апгрейд к Module Federation при необходимости независимых релизов фич.

## Цели и метрики

- Onboarding < 30 сек: авторизация через initData, готовность к игре сразу после старта.
- P95 latency: REST < 200 мс, WS‑события < 200 мс в пределах региона.
- Надёжность: успешная доставка WS‑событий ≥ 99.9%. Устойчивый реплей истории для поздних подписчиков.
- Качество генерации: ≥ 95% валидных structured outputs по JSON Schema.
- Затраты: отчёт о стоимости OpenAI на сессию/игрока, цель — удерживать <$0.05/сцену (пример).

## Основные сценарии (MVP → расширение)

1) Авторизация и лобби
   - Обмен Telegram initData → JWT. Хранение токена с TTL на клиенте. App‑shell с AuthGate.
2) Party Sync
   - Подключение к кампании по WS. Отправка/получение событий, реплей для позднего клиента.
3) Media Jobs
   - Постановка задач TTS/IMG. Идемпотентность (clientToken), polling статусов, кэш результатов.
4) Генерация и память
   - Профили генерации (genlayers) с JSON Schema. Поиск в памяти (memory37 + pgvector), смешанные ответы.
5) Наблюдаемость/Безопасность/CI/CD
   - Логи/трейсы/метрики, OWASP API, пайплайны и контейнеры для независимых релизов сервисов.

## Архитектурные границы

- Контракты: источник истины (OpenAPI/JSON Schema/CloudEvents). Версионирование SemVer и /v1, /v2.
- Сервисы: независимые контейнеры с явными API. Никаких импортов кода между сервисами.
- Плагины: SPI для провайдеров LLM/TTS/IMG/Embeddings/Storage; выбор через конфиг.
- Клиент: feature‑модули регистрируются в runtime, имеют единый контракт и общий доступ к API/логгеру.

## Риски и ограничения

- Пропускная способность/квоты OpenAI → кэширование, ретраи, fallbacks, бюджет токенов.
- Ограничения производительности Mini App → строгий контроль размера бандла и lazy‑imports.
- Сетевые задержки/дисконнекты WS → реплей истории, back‑pressure, таймауты/ретраи.

## Дорожная карта

- Соответствует документу docs/roadmap/EPOCHS.md; релизы инкрементальные, по микросервисам и фичам.

