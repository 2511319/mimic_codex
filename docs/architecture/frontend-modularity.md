# Фронтенд‑модули: варианты и рекомендация

Цель: обеспечить простое и удобное подключение новых фич и технологий без превращения клиента в монолит, с учётом ограничений Telegram Mini App (размер бандла, время старта).

## Варианты

1) App‑shell + Feature Registry (lazy‑imports)
   - Описание: базовое приложение предоставляет «каркас» (роутер, DI/контекст, API‑клиент, логгер). Фичи — отдельные модули, которые регистрируют маршруты/виджеты через единый реестр. Загрузка по demand (dynamic import()).
   - Плюсы: простота, стабильный DX, быстрый старт, минимальный runtime‑оверход, единая сборка.
   - Минусы: общий релиз клиента; фичи не релизятся полностью независимо.

2) Module Federation (runtime composition)
   - Описание: хост‑приложение динамически подцепляет удалённые модули (remoteEntry) с версионированием и шарингом зависимостей.
   - Плюсы: независимые релизы фич, гибкая поставка.
   - Минусы: рост сложности (версии/совместимость/кэш), runtime‑риски, больше усилий на DevOps и observability; не всегда оправдано для Mini App.

3) Микрофронтенды через iframe/внешние страницы
   - Плюсы: сильная изоляция, любые стек‑вариации.
   - Минусы: UX‑разрывы, ограничения Telegram, высокие накладные; обычно избыточно.

## Рекомендация

Стартовать с App‑shell + Feature Registry как базовой архитектуры (Vite + React), обеспечить границы модулей и контракты, чтобы при необходимости эволюционировать к Module Federation для отдельных фич.

Причины:
- Минимальный TTI (time‑to‑interactive) критичен для Mini App.
- Простая эксплуатация и стабильный DX команды.
- Детерминированный бандл и кэширование.

## Контракты фич (пример)

```ts
// Тип манифеста фичи (пример)
export interface FeatureManifest {
  id: string;
  routeBase: string;           // "/media", "/party" и т.п.
  init?: () => Promise<void>;  // инициализация: локаль, трекинг, DI
  getRoutes: () => Promise<RouteObject[]>; // lazy‑routes
}

// Пример реестра
export type FeatureRegistry = {
  register: (loader: () => Promise<FeatureManifest>) => void;
  list: () => FeatureManifest[];
};
```

Интеграция:
- app‑shell (App.tsx) инициализирует FeatureRegistry и подхватывает манифесты (локальные или удалённые).
- Каждая фича экспортирует манифест и лениво предоставляет свои маршруты и зависимости.

## Артефакты для реализации

- apps/webapp/src/feature/registry.ts — интерфейс и простая реализация реестра.
- apps/webapp/src/feature/types.ts — контракты манифеста и DI контекста.
- apps/webapp/src/features/* — пример фичи (party, media), lazy‑routes.
- Документация по сборке и правилам версионирования манифестов.

## Путь к Federation

- Сохранить стабильные API манифеста и контракты маршрутов.
- Ввести семантические версии фич и адаптер хоста для подмены local → remote.
- Добавить fallback на локальные версии при недоступности remoteEntry.

