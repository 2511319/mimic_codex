# Глава 9. Генеративные слои и креативные компоненты

Цель главы — зафиксировать **как именно** мы генерируем текст, изображения и озвучку, какими профилями и шаблонами пользуемся, как соединяем это с «Память37» (Гл. 8), контрактами (Гл. 4), медиапайплайном (Гл. 5) и QA/операциями (Гл. 6). В рантайме работаем **только через OpenAI API**; AugmentCode — лишь исполнитель кода и поставщик артефактов.

## 9.0 Принципы (зачем и что фиксируем)

1.  **Задачи разделены на профили.** Текст = четыре режима (Scene / Combat / Social(VDM) / Epilogue). Разделение снижает дрейф тона и облегчает тестирование качества.
2.  **System-политика и Structured Outputs.** Тон, запреты, «правила решает движок, не модель» — в system. Выход — **строгий JSON** по схеме (Structured Outputs), чтобы UI/логика не падали и были машинно проверяемы.
3.  **Инструменты (MCP/Tools) — по делу.** Используем tool_choice: "auto" — модель сама решает, когда звать rules_lookup / dice_roll / lore_search / lore_assert / npc_profile / art_suggest. При сбоях — деградация без лора (только SRD+state).
4.  **Контекст строго из Гл. 8.** Сцена + top-N лор-чанков + 1–2 сводки + профиль NPC/локации + (опц.) ArtCard-контекст. Никаких «простыней истории».
5.  **Мобильное первое.** Графика — под мобильные экраны: жёстко ограничиваем размеры и готовим responsive-варианты из одного мастер-рендера (см. § 9.8). Для TTS — стриминг (быстрый старт).
6.  **Язык всегда по партии.** Язык вывода **строго = party.lang**; автодетект и фолбэки отключены. Индексы лора — двуязычные; при ретриве модель переводит в язык партии.

## 9.1 Роли генерации и профили

### 9.1.1 Профили текста

- **Scene** — основное повествование (описание, 1–3 варианта выбора, необязательный «visual brief» для арта).
- **Combat** — сухая, тактическая подача (короче, сдержаннее, меньше «поэзии»).
- **Social (VDM-lite)** — диалоговая форма, краткие реплики, соблюдение голоса NPC (из профиля).
- **Epilogue** — ёмкие финалы/резюме, «сшивка» веток.

### 9.1.2 Бюджеты токенов (инпут/аутпут)

- **Scene:** ≤ 1.8 k in, ≤ 350–500 out
- **Combat:** ≤ 1.6 k in, ≤ 220–320 out
- **Social:** ≤ 1.6 k in, ≤ 240–360 out
- **Epilogue:** ≤ 1.2 k in, ≤ 220–320 out

### 9.1.3 Температура/вариативность

- **Scene:** temperature≈0.6–0.8
- **Combat:** ≈0.4–0.6
- **Social:** ≈0.7–0.9
- **Epilogue:** ≈0.5–0.7

Смысл: у каждого профиля — свой «характер». Так мы держим стиль, длину и стоимость в рамках.

## 9.2 System-политика и сборка контекста (стыковка с Гл. 8)

### 9.2.1 System-метадиректива (общая)

- Роль: «Ты — рассказчик. СТРОГО: правила, броски, числа — делает движок. Любые факты лора — через инструменты (по запросу). Соблюдай тон из Гл. 1; следуй Lines & Veils; модерация — приоритетна».
- Безопасность и стиль (терминология, измерения, кавычки/типографика, табу-темы).
- Язык **всегда** = party.lang (указан в контексте партии).

Смысл: единый «закон жанра» и безопасность в одном месте, одинаково применимом к любому профилю.

### 9.2.2 Что кладём в prompt (каждый вызов)

1.  System-политика (строго фиксируется).
2.  **SRD** (по необходимости): 1–2 чанка из ретрива.
3.  **Lore**: top-N по локации/NPC/терминам.
4.  **Episode**: 1–2 кратких сводки + флаги.
5.  **NPC-профили** задействованных персонажей.
6.  **Art-контекст** (если нужен арт): краткие теги/стиль из ArtCard.
7.  **User input** (выбор/реплика).

Базируется на «Память37». Это минимальный, но достаточный контекст — и дешёвый.

## 9.3 Structured Outputs: строгий JSON

### 9.3.1 Причины и поддержка

- Позволяет **жёстко валидировать** ответ (UI, логи, MCP-триггеры).
- Поддерживается через response_format: { type: "json_schema", json_schema: …, strict: true } (Responses API).

### 9.3.2 Схемы (главные)

**SceneResponse.schema.json**

{

"type": "object",

"required": \["narration","choices","lang","safety_notes"\],

"properties": {

"narration": { "type": "string", "maxLength": 1800 },

"choices": {

"type": "array", "minItems": 1, "maxItems": 3,

"items": { "type": "string", "maxLength": 140 }

},

"tags": { "type": "array", "items": { "type": "string", "maxLength": 32 }, "maxItems": 8 },

"art_prompt": { "type": "string", "maxLength": 300 },

"safety_notes": { "type": "string", "maxLength": 200 },

"lang": { "type": "string", "enum": \["ru","en"\] }

},

"additionalProperties": false

}

**CombatResponse.schema.json** — narration, effect_hints\[\], safety_notes, lang.  
**SocialResponse.schema.json** — turns\[\]: {speaker, text}, npc_intent?, safety_notes, lang.  
**EpilogueResponse.schema.json** — narration, closure_tags\[\], lang.

Смысл: JSON — интерфейсный контракт генерации, проверяемый в рантайме. Если не прошёл — авто-репарация мини-перезапросом.

## 9.4 Tools/MCP (вызов функций OpenAI-моделями)

- Настройка: tool_choice: "auto" — модель сама решает, звать ли инструмент (или несколько), либо сгенерировать «обычное» сообщение. При необходимости сдвигаем в required/none.
- Базовый набор: rules_lookup, dice_roll, lore_search, lore_assert, npc_profile, session_fetch, art_suggest.
- Отказоустойчивость: retry-политика и **fallback** (если lore_search недоступен → сцена без лора — только SRD+state; логируем).
- Трассировка инструментов — в OTel вместе с llm-спанами.

Смысл: ИИ не «придумывает цифры»; вся арифметика и канон — через инструменты/движок, как зафиксировано в Гл. 3–4.

## 9.5 Промпт-шаблоны и версии

- Храним шаблоны профилей в /prompts/&lt;profile&gt;/vX/… + SemVer и alias current; A/B — параллельно vX vs vY.
- Шаблон = system.md + assistant_preamble.md + user_frame.md (композиция).
- Контроль изменений через PR-ревью + автотест «goldens» (эталонные сцены).

Смысл: промпт-инженерия — тоже код с версиями. Снижаем регрессии и «магические правки». (Общая рекомендация OpenAI — вести промпты как код.)

## 9.6 Пост-процессинг: безопасность, сжатие для памяти, валидность

1.  **Safety-разметка**: модель возвращает safety_notes; при подозрении — модерация/фильтры (Гл. 1/6).
2.  **Сводка для «Память37»**: nano-шаг — JSON-факты/сводка (коротко), запись в Episodic Summary (Гл. 8).
3.  **Авто-ремонт JSON**: если не прошёл strict-валидацию — небольшой перезапрос «верни по схеме».

## 9.7 Язык и локализация

- **Всегда** выводим текст на языке партии (party.lang). Ни авто-детекта, ни фолбэков.
- Ретрив лора — двуязычный (эмбеддинги мульти-язычные): если чанк не на языке партии, модель **сама** кратко переформулирует факт на нужный язык.
- Единые правописные правила (кавычки, имена, единицы) — в system.

Смысл: UX и команда партии всегда получают единообразный язык; источники могут быть смешанными, но генерация — строго по партии.

## 9.8 Генерация изображений (gpt-image-1) — mobile-first

### 9.8.1 Когда рисовать

- Не всегда. Рисуем при триггерах: «важная сцена», «новый ключевой NPC/локация», «предмет-крупняк». Это экономит бюджет (Гл. 5).

### 9.8.2 Источник визуального брифа

- Авто-извлечение из SceneResponse: поле art_prompt + теги из текста + стиль/seed из ArtCard (если серия).
- Правим бриф (микро-LLM шаг) до 250–300 символов.

### 9.8.3 Параметры API и размеры (под мобильные)

- **Мастер-рендер**: size=1024 (квадрат) + quality=low|medium по профилю (low по умолчанию; medium — на «геройских» сценах).
- На клиент/в CDN — готовим responsive-варианты:
    - **Hero** (полноэкранный блок): 1024 px (srcset: 768/1024)
    - **Карточка сцены/локации**: 512–768 px
    - **Инвентарь/иконки**: 256 px
- Seed фиксируем в ArtCard, чтобы серия/повтор были воспроизводимы.

Смысл: один мастер — и дешёвые мобильные варианты «сверху» через CDN/ресайз. quality управляет детальностью, size — разрешением (официально различаются)

## 9.9 Озвучка / Realtime

- **Где включаем TTS:** только на ключевых сценах и в репликах NPC; в остальных — кнопка «озвучить» (по запросу).
- **Стриминг**: используем Realtime/TTS стрим — быстрый старт воспроизведения, снижение латентности.
- **Голоса**: из NPC.voice_tts (профиль, Гл. 8); у рассказчика — нейтральный голос кампании.

Смысл: «звук по требованию» + стриминг = быстрый UX без взрывов бюджета.

## 9.10 Стоимость, кэш и профили качества

- **Профили**:
    - Fast: mini-модель на сцену; k=8–10 ретрива; картинки — quality=low; TTS — «по кнопке».
    - Quality: те же модели, но k=12 и quality=medium лишь на ключевых сценах; бо́льшие лимиты аутпута.
- **Кэш по хэшу** промпта/контекста (текст, арт, TTS) + инвалидация по версии лора/темплейта.
- **Счётчики**: токены in/out, tool_calls, изображения/TTS, цена на ход (см. OTel метрики, Гл. 6).

## 9.11 A/B и контроль креатива

- **A/B**: сравниваем версии шаблонов (/prompts/…/vX vs vY), метрики — time-to-choice, % early-back, рейтинг сцены.
- **Golden-сцены**: эталоны жанров/ситуаций; сравнение стиля и структуры (регрессы).
- **Эвристики качества**: длина абзацев, повторы, клише, присутствие лор-терминов.

## 9.12 Безопасность и модерация

- Вход/выход сцены — через модерацию; спорные — вручную.
- В артах — moderation-флаг на ArtCard + ручная проверка для спорных комбинаций.
- LLM **не изменяет** механику/цифры — только повествование; любые «факты» — через lore_assert/ретрив.

## 9.13 Артефакты главы (что кладём в репозиторий)

- /prompts/scene|combat|social|epilogue/vX/ — system / assistant_preamble / user_frame.
- /schemas/SceneResponse.schema.json, CombatResponse.schema.json, SocialResponse.schema.json, EpilogueResponse.schema.json.
- /mcp/tools/\*.yaml — описания инструментов (совм. с Гл. 8).
- /ab-tests/&lt;date&gt;-&lt;profile&gt;-vX-vY.yaml — карточки экспериментов.
- /goldens/ — эталонные сцены/диалоги.
- /configs/generation.yaml — все лимиты, температуры, профили, флаги изображений/TTS.

## 9.14 DoR / DoD

**Definition of Ready (перед стартом реализации):**

- Промпт-шаблоны 4 профилей подготовлены и версионированы.
- JSON-схемы обще-утверждены и подключены в Responses API (strict: true).
- MCP-tools доступны с tool_choice: "auto" + деградации прописаны.
- Параметры генерации/бюджеты зафиксированы; язык = party.lang повсюду.
- Графика — политика мобильных размеров принята (1024 мастер; 768/512/256 responsive).

**Definition of Done (что считаем «сделано»):**

- Все профили возвращают валидный JSON; доля авто-ремонта < 1%.
- A/B-рамка в CI; golden-сцены проходят без регрессов.
- Телеметрия/алерты по llm-генерации, tools, cost/turn.
- Кэш на текст/арт/TTS с инвалидацией по версиям.
- Озвучка работает в стриме; голоса NPC берутся из профилей.

## 9.15 Кратко: что и зачем

- **Профили + system** дают стабильный стиль, а **Structured Outputs** — машинную проверяемость и отказоустойчивость UI
- **Tools с tool_choice: "auto"** вплетают правила и лор как «истины из движка», не допуская самовольных чисел от модели.
- **Контекст по Гл. 8** (сводки/лор/NPC/ArtCard) убирает «потерю памяти» и держит канон.
- **Мобильная графика** (1024 мастер → 768/512/256) сохраняет бюджет и скорость; quality ≠ size.
- **TTS-стриминг** улучшает UX без ощутимого роста цены.

**Validation (2 строки):** Глава 9 полностью согласована с Главами 1–8 и включает выбранные оптимальные решения + ваши оговорки (мобильные размеры изображений; язык строго по партии). Неопределённость закрыта: есть профили, схемы, инструменты, параметры, артефакты и критерии готовности.